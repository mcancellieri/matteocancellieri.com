<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Competition Downloader</title>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js" defer></script>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, sans-serif; margin: 0; padding: 24px; line-height: 1.5; }
    main { max-width: 900px; margin: 0 auto; display: grid; gap: 16px; }
    textarea, pre, input[type="number"] { width: 100%; box-sizing: border-box; font: 14px/1.4 ui-monospace, SFMono-Regular, Menlo, monospace; padding: 10px; border-radius: 6px; border: 1px solid #bbb; }
    textarea { min-height: 180px; }
    button { padding: 10px 14px; border-radius: 6px; border: 1px solid #222; background: #222; color: #fff; cursor: pointer; }
    button:hover { opacity: 0.9; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    label { font-weight: 600; }
    .error { color: #c00; font-weight: 600; }
    ul { padding-left: 16px; }
    li { word-break: break-all; }
    @media (max-width: 640px) { .row { flex-direction: column; align-items: flex-start; } button { width: 100%; } }
  </style>
</head>
<body>
<main>
  <nav>
    <a href="index.html">CSV Randomiser</a> |
    <a href="download_competition.html">Competition Downloader</a> |
    <a href="subscription_manager.html">Subscription Manager</a>
  </nav>

  <header>
    <h1>Competition Downloader</h1>
    <p>Paste the competition TSV/CSV rows (must include a Google Drive link column). This tool builds a download list and can pull files via a Cloudflare Worker proxy (add its URL below) to avoid Drive CORS.</p>
  </header>

  <section>
    <label for="raw-input">Spreadsheet paste</label>
    <textarea id="raw-input" placeholder="Paste rows here..."></textarea>
  </section>

  <section class="row">
    <label>Seed: <input type="number" id="seed" value="1" min="0" /></label>
    <label><input type="checkbox" id="include-names" checked /> Include names in render</label>
    <button id="generate">Generate order</button>
  </section>

  <section>
    <div class="row">
      <button id="scan-links">Scan Google Drive links</button>
      <button id="open-links">Open all links</button>
      <button id="download-images">Download via proxy</button>
    </div>
    <label for="proxy-url">Proxy base URL (Cloudflare Worker):</label>
    <input id="proxy-url" type="url" placeholder="https://your-worker.subdomain.workers.dev" />
    <div id="links-status"></div>
    <ul id="links-list"></ul>
  </section>

  <section>
    <div id="error" class="error" role="status" aria-live="polite"></div>
    <pre id="output" aria-live="polite"></pre>
  </section>
</main>

<script>
  const input = document.getElementById("raw-input");
  const output = document.getElementById("output");
  const errorBox = document.getElementById("error");
  const includeNames = document.getElementById("include-names");
  const seedField = document.getElementById("seed");
  const linksStatus = document.getElementById("links-status");
  const linksList = document.getElementById("links-list");
  const proxyUrlField = document.getElementById("proxy-url");

  let lastLinks = [];
  let lastParsed = [];

  const rngFromSeed = (seed) => {
    let s = seed >>> 0;
    return () => {
      s += 0x6d2b79f5;
      let t = Math.imul(s ^ (s >>> 15), 1 | s);
      t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  };

  const shuffle = (arr, seed) => {
    const next = rngFromSeed(seed);
    for (let i = arr.length - 1; i > 0; i -= 1) {
      const j = Math.floor(next() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  };

  const alphabetLabel = (index) => {
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let n = index;
    let label = "";
    do {
      label = letters[n % 26] + label;
      n = Math.floor(n / 26) - 1;
    } while (n >= 0);
    return label;
  };

  const parseLine = (line, delimiter) => {
    if (delimiter === "\t") return line.split("\t");
    const cells = [];
    let current = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i += 1) {
      const char = line[i];
      if (char === '"' ) {
        if (inQuotes && line[i + 1] === '"') { current += '"'; i += 1; continue; }
        inQuotes = !inQuotes;
        continue;
      }
      if (char === delimiter && !inQuotes) { cells.push(current); current = ""; continue; }
      current += char;
    }
    cells.push(current);
    return cells;
  };

  const processInput = (text) => {
    const delimiter = text.includes("\t") ? "\t" : ",";
    const rows = text
      .split(/\r?\n/)
      .map((line) => line.trim())
      .filter(Boolean)
      .map((line) => parseLine(line, delimiter));

    const errors = [];
    const parsed = [];

    rows.forEach((row, idx) => {
      if (row.length < 7) {
        errors.push(`Row ${idx + 1} has only ${row.length} column(s); need at least 7 (incl. link).`);
        return;
      }
      parsed.push({
        name: row[1]?.trim() ?? "",
        title: row[3]?.trim() ?? "",
        medium: row[4]?.trim() ?? "",
        size: row[5]?.trim() ?? "",
        link: row[6]?.trim() ?? "",
        originalRow: row,
      });
    });

    if (!parsed.length) errors.push("No valid rows found.");
    return { parsed, errors };
  };

  const renderOutput = (items, showNames) =>
    items
      .map((item, idx) => {
        const label = alphabetLabel(idx);
        const namePrefix = showNames && item.name ? `${item.name}, ` : "";
        return `${label}: ${namePrefix}${item.title}, ${item.medium}, ${item.size}`;
      })
      .join("\n");

  const collectDriveLinks = (items) => {
    const links = [];
    const drivePattern = /(drive\.google\.com|googleusercontent\.com)/i;
    items.forEach((item, idx) => {
      item.originalRow?.forEach((cell) => {
        const val = (cell || "").trim();
        if (drivePattern.test(val) && val.startsWith("http")) {
          links.push({ idx, url: val });
        }
      });
      if (item.link && drivePattern.test(item.link)) {
        links.push({ idx, url: item.link });
      }
    });
    return Array.from(new Set(links.map((l) => JSON.stringify(l)))).map((s) => JSON.parse(s));
  };

  const driveToDirect = (url) => {
    const idFromIdParam = url.match(/id=([^&]+)/);
    const idFromPath = url.match(/\/d\/([^/]+)/);
    const fileId = idFromIdParam?.[1] || idFromPath?.[1];
    if (fileId) return `https://drive.google.com/uc?export=download&id=${fileId}`;
    return url;
  };

  const renderLinks = (links) => {
    linksList.innerHTML = "";
    links.forEach((l) => {
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = l.url;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = l.url;
      li.textContent = `Row ${l.idx + 1}: `;
      li.appendChild(a);
      linksList.appendChild(li);
    });
  };

  document.getElementById("generate").addEventListener("click", () => {
    errorBox.textContent = "";
    output.textContent = "";
    linksStatus.textContent = "";
    linksList.innerHTML = "";

    const raw = input.value.trim();
    if (!raw) {
      errorBox.textContent = "Please paste some spreadsheet rows first.";
      return;
    }

    const seed = Number(seedField.value) || 1;
    const { parsed, errors } = processInput(raw);

    if (errors.length) {
      errorBox.textContent = errors.join(" ");
      if (!parsed.length) return;
    }

    shuffle(parsed, seed);
    output.textContent = renderOutput(parsed, includeNames.checked);
    lastLinks = collectDriveLinks(parsed);
    lastParsed = parsed;
  });

  document.getElementById("scan-links").addEventListener("click", () => {
    linksStatus.textContent = "";
    linksList.innerHTML = "";
    const raw = input.value.trim();
    if (!raw) {
      linksStatus.textContent = "Paste spreadsheet data first.";
      return;
    }
    const { parsed, errors } = processInput(raw);
    lastParsed = parsed;
    if (errors.length && !parsed.length) {
      linksStatus.textContent = errors.join(" ");
      return;
    }
    lastLinks = collectDriveLinks(parsed);
    if (!lastLinks.length) {
      linksStatus.textContent = "No Google Drive links found.";
      return;
    }
    linksStatus.textContent = `Found ${lastLinks.length} Google Drive link(s).`;
    renderLinks(lastLinks);
  });

  const openAllLinks = () => {
    if (!lastLinks.length) {
      linksStatus.textContent = "Scan links first, or include links in the data.";
      return;
    }
    linksStatus.textContent = "Opening links in new tabs (your browser may block pop-ups).";
    lastLinks.forEach((l, i) => {
      setTimeout(() => window.open(l.url, "_blank", "noopener,noreferrer"), i * 50);
    });
  };
  document.getElementById("open-links").addEventListener("click", openAllLinks);

  const downloadViaProxy = async () => {
    if (!lastLinks.length) {
      linksStatus.textContent = "Scan links first, or include links in the data.";
      return;
    }
    const proxyBase = proxyUrlField.value.trim().replace(/\/+$/, "");
    if (!proxyBase) {
      linksStatus.textContent = "Provide your Cloudflare Worker URL to proxy downloads.";
      return;
    }
    if (!window.JSZip) {
      linksStatus.textContent = "JSZip failed to load; cannot create archive.";
      return;
    }

    linksStatus.textContent = "Downloading via proxy (this may take a while)...";
    const zip = new JSZip();
    const results = await Promise.allSettled(
      lastLinks.map(async (link, i) => {
        const direct = encodeURIComponent(driveToDirect(link.url));
        const proxyUrl = `${proxyBase}/?url=${direct}`;
        const res = await fetch(proxyUrl);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const blob = await res.blob();
        const ext = blob.type.split("/")[1] || "bin";
        const filename = `row-${link.idx + 1}-${i + 1}.${ext}`;
        zip.file(filename, blob);
        return filename;
      })
    );

    const failures = results.filter((r) => r.status === "rejected");
    const successCount = results.length - failures.length;

    if (successCount === 0) {
      linksStatus.textContent = "Could not download images (proxy may be misconfigured or Drive may block access).";
      return;
    }

    const blob = await zip.generateAsync({ type: "blob" });
    const linkEl = document.createElement("a");
    linkEl.href = URL.createObjectURL(blob);
    linkEl.download = "competition-images.zip";
    linkEl.click();
    URL.revokeObjectURL(linkEl.href);

    const failMsg = failures.length ? ` ${failures.length} failed.` : "";
    linksStatus.textContent = `Downloaded ${successCount} file(s) via proxy.${failMsg}`;
  };

  document.getElementById("download-images").addEventListener("click", () => {
    downloadViaProxy().catch((err) => {
      console.error(err);
      linksStatus.textContent = "Unexpected error during download.";
    });
  });
</script>
</body>
</html>

